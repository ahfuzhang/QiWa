
* http 1.1:
  - kestrel
* http 2
  - kestrel
* grpc:
  - Grpc.Tools 代码生成
  - Grpc.Net.ClientFactory 工厂方式建立客户端
  - Grpc.Net.Client 客户端
  - Grpc.AspNetCore 服务端
* 对象池:
  - Microsoft.Extensions.ObjectPool

```csharp
using System;
using Microsoft.Extensions.ObjectPool;

public class MyReusable
{
    public Guid Id { get; } = Guid.NewGuid();
    public void Reset() { /* 清理状态 */ }
}

public class MyReusablePolicy : PooledObjectPolicy<MyReusable>
{
    public override MyReusable Create() => new MyReusable();
    public override bool Return(MyReusable obj)
    {
        obj.Reset();
        return true; // true 表示对象可重用
    }
}

class Program
{
    static void Main()
    {
        var provider = new DefaultObjectPoolProvider { MaximumRetained = 32 };
        ObjectPool<MyReusable> pool = provider.Create(new MyReusablePolicy());

        // using 自动归还
        using (var lease = pool.Get(out var item))
        {
            Console.WriteLine($"Using {item.Id}");
            // 这里使用 item
        } // 离开作用域时 lease.Dispose() 调用 pool.Return(item)
    }
}

```

* 命令行解析

```csharp
using System.CommandLine;

var port = new Option<int>(
    "--port",
    getDefaultValue: () => 8080,
    description: "Listen port");

var verbose = new Option<bool>("--verbose");

var root = new RootCommand("My Server")
{
    port,
    verbose
};

root.SetHandler((int p, bool v) =>
{
    Console.WriteLine($"port={p}, verbose={v}");
}, port, verbose);

return await root.InvokeAsync(args);
```

* zstd 压缩
  - dotnet add package ZstdNet

```csharp
using ZstdNet;

byte[] data = GetData();

using var compressor = new Compressor(level: 3);
byte[] compressed = compressor.Wrap(data);

using var decompressor = new Decompressor();
byte[] restored = decompressor.Unwrap(compressed);

// 基于流的模式
using var zstd = new ZstdNet.CompressionStream(
    outputStream,
    CompressionOptions.Default);

inputStream.CopyTo(zstd);
```

* redis 访问
  - dotnet add package StackExchange.Redis

```csharp
using StackExchange.Redis;

var mux = await ConnectionMultiplexer.ConnectAsync("localhost:6379");
IDatabase db = mux.GetDatabase();

// 写
await db.StringSetAsync("key", "value");

// 读
string value = await db.StringGetAsync("key");
```

* mysql 访问
  - dotnet add package MySqlConnector

```csharp
using MySqlConnector;

var cs = "Server=localhost;User ID=root;Password=123;Database=test";

await using var conn = new MySqlConnection(cs);
await conn.OpenAsync();

await using var cmd = new MySqlCommand(
    "SELECT id, name FROM users WHERE id = @id", conn);

cmd.Parameters.AddWithValue("@id", 1);

await using var reader = await cmd.ExecuteReaderAsync();

while (await reader.ReadAsync())
{
    int id = reader.GetInt32(0);
    string name = reader.GetString(1);
}
```

* async local 技术

```csharp
static AsyncLocal<string> UserId = new();

async Task HandleAsync()
{
    UserId.Value = "A";
    await Task.Delay(10);
    Console.WriteLine(UserId.Value); // ✅ 一定是 "A"
}
```

* 高性能的只读 map

```csharp
static readonly FrozenDictionary<string, int> StatusMap =
    new Dictionary<string, int>
    {
        ["OK"] = 200,
        ["NOT_FOUND"] = 404,
        ["ERROR"] = 500
    }.ToFrozenDictionary();
```

* AsyncLocal<T>
  - ExecutionContext（异步执行上下文）， 绑定了 ExecutionContext

```csharp
static AsyncLocal<string> User = new();

User.Value = "A";
await Foo();
Console.WriteLine(User.Value); // ✅ 仍然是 "A"
```

* 使用 thread local 来提升性能
  - 每个线程一个 stdout 的输出 buffer

* 命令行选项

```csharp
using System.CommandLine;
using System.CommandLine.Invocation;

        var urlOption = new Option<Uri>(new string[] { "-u", "--url" }, "The server url to request") { IsRequired = true };
        var udsFileNameOption = new Option<string>(new string[] { "--udsFileName" }, "The Unix Domain Socket file name");

```
